âœ… React.StrictMode â€“ Master Notes
Covers: Lifecycle checks, side-effects, concurrent prep, effect cleanup testing, and best practices.

ğŸ”° 1. What is React.StrictMode?
<React.StrictMode> is a development-only helper wrapper that helps identify potential problems in your React components.

jsx
Copy
Edit
<React.StrictMode>
  <App />
</React.StrictMode>
ğŸ” Detects unsafe lifecycle methods

âš ï¸ Warns about deprecated APIs

ğŸ” Double-invokes useEffect, componentDidMount, etc.

ğŸ§¼ Checks for memory leaks and cleanup issues

âœ… Does not render anything in UI or affect production builds.

ğŸ› ï¸ 2. Why Use StrictMode?
StrictMode:

Surfaces unexpected side-effects

Helps make your app ready for Concurrent Rendering

Assists in migrating legacy code

ğŸš« Does not block rendering, but logs warnings in console.

ğŸ§ª 3. How StrictMode Works
ğŸ” Re-invokes rendering logic:
Triggers useEffect / componentDidMount / componentWillUnmount

Detects impure rendering or leaking effects

âŒ Flags the following legacy lifecycle methods as unsafe:
Deprecated Lifecycle Methods
componentWillMount
componentWillReceiveProps
componentWillUpdate

Use alternatives like:

componentDidMount

getDerivedStateFromProps

useEffect

âš™ï¸ 4. Behavior with useEffect
StrictMode tests cleanup logic by:

js
Copy
Edit
useEffect(() => {
  console.log('Effect ran');
  return () => console.log('Cleanup');
}, []);
Expected console:

nginx
Copy
Edit
Effect ran
Cleanup
Effect ran
âœ… Only in development
âŒ Not repeated in production

ğŸ§¼ 5. Detecting Side Effects
StrictMode helps detect:

Async effects that donâ€™t clean up

DOM mutations outside useEffect

Using useLayoutEffect where useEffect would suffice

ğŸ§± 6. Testing Cleanup and Mounting Logic
StrictMode simulates mount â†’ unmount â†’ mount immediately:

Useful to detect memory leaks

Helps test resource initialization and teardown

Use this pattern to avoid memory leaks:

js
Copy
Edit
useEffect(() => {
  const id = setInterval(...);
  return () => clearInterval(id); // cleanup
}, []);
âš™ï¸ 7. Concurrent Rendering Preparation
StrictMode prepares components for Concurrent Mode by:

Emulating re-entrancy

Warning for impure code or DOM mutations during render

ğŸ” Doesnâ€™t enable full concurrent rendering
âœ… Makes component compatible with future concurrent features

ğŸ§  8. Effect on React.memo and Memoization
React.memo components may re-render unexpectedly under StrictMode

Used to detect impure memoized components

âœ… Donâ€™t remove memoization
âš ï¸ Ensure pure rendering functions

âš¡ 9. useLayoutEffect vs useEffect Warnings
StrictMode warns when:

useLayoutEffect blocks painting

It can be replaced with useEffect safely

â±ï¸ useLayoutEffect runs synchronously before paint
âœ… Use only for synchronous DOM measurements
âŒ Avoid using it for side effects like API calls

ğŸ§© 10. Can You Nest or Scope StrictMode?
Yes âœ…

You can wrap only parts of the app:

jsx
Copy
Edit
<StrictMode>
  <Header />
</StrictMode>
<Main /> // not in strict mode
ğŸ’¡ Useful for gradual adoption in large legacy apps

ğŸ›¡ï¸ 11. Is StrictMode Used in Production?
No âŒ
It is stripped out during build (react-dom.production.min.js).

StrictMode is strictly for development & debugging

ğŸ”„ 12. How to Add StrictMode in Legacy Codebases
Steps:

Wrap new components in <StrictMode>

Fix console warnings

Expand to more components gradually

Replace third-party libraries if needed

ğŸ§± 13. StrictMode Limitations
Limitation	Description
ğŸ›  Dev Only	No effect in production
âŒ Not a Bug Catcher	Doesn't catch all runtime bugs
ğŸ§ª Focuses Only on Lifecycle & Side Effects	Doesnâ€™t verify logic, UI, or API issues

âš ï¸ 14. StrictMode Common Warnings You Might See
Warning: Unsafe lifecycle methods

Warning: useEffect cleanup not handled

Warning: DOM mutations outside effect

Warning: useLayoutEffect blocks paint

ğŸ” 15. StrictMode Summary Table
Feature	Enabled in Dev?	Enabled in Prod?	Notes
Warns on unsafe lifecycles	âœ…	âŒ	console warning
Double run of effects	âœ…	âŒ	for cleanup test
Detects legacy patterns	âœ…	âŒ	warns on deprecated methods
Simulates unmount/remount	âœ…	âŒ	test resource handling
Helps prepare for Concurrent	âœ…	âŒ	useful before adopting concurrency

