

# ğŸ§  **React State â€“ Master Notes**

*Covers: `useState`, updates, batching, stale closures, performance optimization, and more.*

---

## âœ… 1. **What is React State?**

State in React is a **plain JavaScript object** used to represent information about the componentâ€™s current situation. When state changes, React re-renders the component.

> In functional components, state is managed using the **`useState` hook**.

```js
const [count, setCount] = useState(0);
```

---

## âœ… 2. **How `useState` Works**

* `useState(initialValue)` returns an **array**:
  `[currentState, setStateFunction]`

### âš¡ Common Patterns:

```js
const [name, setName] = useState('Shubham');
const [user, setUser] = useState({ name: '', age: 0 });
```

---

## âœ… 3. **Updating State**

State is **never updated directly**.

ğŸš« `count = count + 1;`
âœ… `setCount(count + 1);`

---

## âœ… 4. **Functional Updates**

Use **functional updates** when new state depends on previous value.

```js
setCount(prev => prev + 1);
```

ğŸ” Especially useful inside **loops**, **async callbacks**, or **debouncing**.

---

## âœ… 5. **Lazy Initialization**

Useful when the initial state requires **expensive computation**.

```js
const [data, setData] = useState(() => computeHeavy());
```

âœ”ï¸ The function runs **only on the first render**.

---

## âœ… 6. **State and Re-rendering**

React re-renders the component when:

* The **state or props** change
* But only if the **new value is different (shallow check)**

ğŸ” Same value? â†’ No re-render.

```js
setCount(5); // If already 5 â†’ No render
```

---

## âœ… 7. **State Batching (React 18+)**

React **batches multiple state updates** into a **single re-render**.

```js
setCount(1);
setName('John');
// Only one render will happen.
```

ğŸ§  Even works inside `setTimeout`, promises, and async/await in React 18+.

---

## âœ… 8. **Immutability in State**

React compares **object references** (not deep equality).

So, always update non-primitive (object/array) state immutably.

```js
setUser(prev => ({ ...prev, name: 'Shubham' }));
```

ğŸ”´ Direct mutation (e.g. `user.name = "New"`) â†’ React wonâ€™t detect.

---

## âœ… 9. **Avoiding Stale State (Closure Issue)**

In async callbacks or handlers, you might read stale values.

ğŸ” Solution: Use functional updates.

```js
setCount(prev => prev + 1);
```

---

## âœ… 10. **Rules of Hooks â€“ No Conditional `useState`**

Hooks must be **called in the same order** on every render.

ğŸš« Donâ€™t do:

```js
if (condition) {
  useState(...); // âŒ
}
```

âœ… Instead:

```js
const [value, setValue] = useState(condition ? 'Yes' : 'No');
```

---

## âœ… 11. **Resetting State**

Reset by calling the setter with the **initial value**.

```js
setCount(0);
```

Each `useState` is **independent**, so reset individually.

---

## âœ… 12. **Sharing State Between Components**

* **Local State** â†’ stays within a component
* To **share** state:

  * **Lift it up** to a common ancestor
  * Use **Context API**
  * Use **Redux** or other global state libs

---

## âœ… 13. **Derived vs Independent State**

**Derived State** = Calculated from props/state
**Independent State** = Manages its own value

ğŸ›‘ Avoid storing derived state in `useState`

âœ… Instead compute during render:

```js
const fullName = `${firstName} ${lastName}`;
```

---

## âœ… 14. **useEffect and State**

### Common issues:

* Infinite loops when setting state inside `useEffect` without proper dependencies
* Cleanup is needed to avoid memory leaks with timers

```js
useEffect(() => {
  const timer = setTimeout(() => {
    setValue(input);
  }, 300);

  return () => clearTimeout(timer);
}, [input]);
```

---

## âœ… 15. **Tracking Previous State**

Use `useRef` to store previous values.

```js
const prevCount = useRef();
useEffect(() => {
  prevCount.current = count;
}, [count]);
```

ğŸŸ¡ `useRef` does **not cause re-renders**.

---

## âœ… 16. **Force a Re-render**

React only re-renders if state changes.

To force a re-render:

```js
const [, forceUpdate] = useState(0);
forceUpdate(n => n + 1);
```

---

## âœ… 17. **Throttle or Debounce State Updates**

Throttle: regulate state update frequency
Debounce: wait until user stops typing

```js
useEffect(() => {
  const id = setTimeout(() => {
    setQuery(input);
  }, 300);
  return () => clearTimeout(id);
}, [input]);
```

---

## âœ… 18. **React 18: `startTransition()`**

Mark **non-urgent state updates** to avoid UI jank.

```js
startTransition(() => {
  setSearchResults(data);
});
```

---

## âœ… 19. **Common Anti-patterns to Avoid**

| âŒ Bad Pattern                        | âœ… Correct Approach                    |
| ------------------------------------ | ------------------------------------- |
| Copying props to state unnecessarily | Derive values in render or useEffect  |
| Mutating state directly              | Use immutable updates (spread, immer) |
| Using useState inside conditionals   | Call useState at top level always     |
| setState in render                   | Move to useEffect or handlers         |

---

## ğŸ§  Extra: React Re-render Triggers Summary

| Trigger                   | Causes Re-render? |
| ------------------------- | ----------------- |
| setState with new value   | âœ…                 |
| setState with same value  | âŒ                 |
| Direct mutation of object | âŒ                 |
| Functional update         | âœ…                 |
| Ref value change          | âŒ                 |

---

Would you like these **converted into a 2-page PDF cheat sheet** or added to your full React interview notes?
