Here are comprehensive notes on **Lambda Expressions in Java** with coding examples, drawing from the provided YouTube source:

### Notes on Lambda Expressions in Java

**1. Introduction to Lambda Expressions**
*   Lambda expressions are a powerful and easy-to-use feature introduced in Java 8 that significantly simplify code.
*   They are essentially **anonymous functions**.
*   Lambda expressions make the process of creating threads much easier, eliminating the need for separate implementation classes or verbose anonymous inner classes.

**2. Functional Interfaces: The Foundation for Lambdas**
*   A **Functional Interface** is an interface that contains **only one abstract method**.
*   It can have default methods and static methods, but only one method without a body.
*   The `@FunctionalInterface` annotation (though not explicitly mentioned in the provided text, it's a standard practice) is typically used to mark such interfaces.
*   **`Runnable` is a functional interface**. This is crucial because `Runnable` has a single abstract method, `run()`, making it a perfect candidate for lambda expressions.

**3. Traditional Thread Creation (with `Runnable` Anonymous Inner Class)**
*   Before lambda expressions, creating a `Runnable` object "on the fly" typically involved an anonymous inner class.

    *   **Example Code (from source):**
        ```java
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Hello");
            }
        }; // This is an object, an on-the-fly implementation class and its object created.

        Thread t1 = new Thread(runnable); // A thread is created using this runnable object.
        t1.start(); // The thread is started.
        ```
*   This approach, while functional, can be verbose. The IDE (like IntelliJ) often suggests replacing such anonymous inner classes with lambda expressions.

**4. Converting a Normal Method to a Lambda Expression**
*   A normal method or function can be converted into an anonymous function (lambda expression) by following these steps:
    1.  Remove the access modifier (e.g., `public`).
    2.  Remove the return type (e.g., `void`, `String`).
    3.  Remove the method name (e.g., `func`, `getBio`).
    4.  Add an **arrow (`->`)** between the small brackets (parameters) and the curly brackets (body).

    *   **Original Method Example (conceptual from source):**
        ```java
        public void func() {
            System.out.println("Hello");
        }
        ```
    *   **Converted Lambda Expression Example (conceptual from source):**
        ```java
        () -> { System.out.println("Hello"); } // Brackets, arrow, and body.
        ```

**5. Thread Creation using Lambda Expressions**
*   Since `Runnable` is a functional interface, its anonymous inner class implementation can be replaced with a lambda expression, making the code much more concise.

    *   **Lambda Equivalent for Thread Creation (from source):**
        ```java
        Runnable taskOne = () -> System.out.println("Hello"); // A single statement body.

        // Or directly within the Thread constructor:
        Thread t1 = new Thread(() -> System.out.println("Hello")); // Directly creating a thread with a lambda.
        t1.start();
        ```
*   This is significantly cleaner as it removes the need for an implementation class or even the verbose anonymous inner class structure.

**6. Lambda Expressions with Parameters and Return Types**
*   Lambda expressions can also handle methods that take parameters and return values, as long as they implement a functional interface.

    *   **Example Functional Interface (`Student` from source):**
        ```java
        interface Student {
            String getBio(String name); // Single abstract method.
        }
        ```
    *   **Traditional Implementation (Anonymous Inner Class):**
        ```java
        Student engineeringStudent = new Student() {
            @Override
            public String getBio(String name) {
                return name + " is Engineering Student";
            }
        };
        String bio = engineeringStudent.getBio("Ram"); // Output: Ram is Engineering Student.
        ```
    *   **Lambda Expression for `Student` Interface (Initial Conversion):**
        ```java
        Student lawStudent = (String name) -> {
            return name + " is Law Student";
        }; // Remove return type, name; add arrow.
        String bioOfRam = lawStudent.getBio("Ram"); // Output: Ram is Law Student.
        ```
    *   **Further Simplifications for Lambdas:**
        *   **Omitting Parameter Type**: If the parameter type is obvious from the context (e.g., `String` for `getBio`), it can be omitted.
            ```java
            Student lawStudent = (name) -> {
                return name + " is Law Student";
            };
            ```
        *   **Omitting Parentheses for Single Parameter**: If there's only one parameter, the parentheses around the parameter list can also be omitted.
            ```java
            Student lawStudent = name -> { // Parentheses removed for a single parameter.
                return name + " is Law Student";
            };
            ```
        *   **Omitting Curly Braces and `return` for Single-Line Body**: If the lambda's body consists of a single statement, especially one that implicitly returns a value, both the curly braces `{}` and the `return` keyword can be omitted. The statement's result is automatically returned.
            ```java
            Student lawStudent = name -> name + " is Law Student"; // Most concise form.
            ```
            *   **Note**: If the return type is `void` and the body is a single statement (e.g., `System.out.println`), then also curly braces can be omitted.
                ```java
                // If Student interface had 'void getBio(String name);'
                Student someStudent = name -> System.out.println(name + " did something");
                ```

**7. Assigning Lambda Expressions to Functional Interfaces**
*   A lambda expression can be assigned to the reference of a functional interface, similar to how an `int` value can be assigned to an `Integer` reference.
*   The type of the lambda expression is inferred from the functional interface it's assigned to.

    *   **Example (from source):**
        ```java
        Runnable task = () -> System.out.println("Hello from Task"); // Lambda assigned to Runnable reference.
        ```
*   This allows for very flexible and concise use of lambda expressions wherever a functional interface is expected.

**8. Multi-line Lambda Bodies**
*   If a lambda expression requires multiple lines of code in its body, curly braces `{}` are necessary, just like a regular method body.

    *   **Example (from source):**
        ```java
        Runnable multiLineTask = () -> {
            for (int i = 0; i < 10; i++) {
                System.out.println("Line " + i);
            }
        };
        Thread t2 = new Thread(multiLineTask);
        t2.start();
        ```
*   Even with multiple lines, the lambda expression remains more compact than an anonymous inner class.
