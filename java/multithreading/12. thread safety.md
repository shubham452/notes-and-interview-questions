Here are comprehensive notes and a coding example on **Thread Communication** in Java, drawing from the provided sources and our conversation history:

### Notes on Thread Communication

**1. What is Thread Communication?**
*   In a multi-threading environment, **threads need to communicate with each other**. This process is known as **Thread Communication**.
*   Without proper communication, threads can enter a **"busy waiting state"**.
*   **Busy waiting** means threads continuously check conditions (e.g., "is my turn yet?"). This constant checking **wastes CPU resources**.
*   This waste can lead to **potential deadlocks**.
*   **Thread communication helps save CPU resources** by allowing threads to inform each other about state changes, rather than constantly polling.

**2. Relationship to Thread Safety**
*   Thread communication is a mechanism used to achieve **thread safety**.
*   An object or code is considered **thread-safe when it guarantees that unexpected results, race conditions, or data corruption will not occur** when multiple threads try to access that object or block of code.
*   The goal of studying concepts like `synchronized`, `ReadWriteLock`, `wait()`, `notify()`, and `ReentrantLock` is to make things thread-safe.
*   Using `wait()`, `notify()`, and `notifyAll()` (along with `synchronized` blocks/methods) helps ensure thread safety by coordinating access and preventing issues like data corruption. If data is not kept thread-safe, unexpected or incorrect results can occur.

**3. Problem Without Thread Communication (Producer-Consumer Analogy)**
*   Consider a **Producer** thread that generates data and a **Consumer** thread that uses it.
*   Without proper inter-thread communication, the Consumer would continuously check if new data is available. This continuous checking is a **waste of CPU resources**.
*   Ideally, the Producer should simply **notify** the Consumer when new data is ready, and vice versa, to avoid this busy waiting.

**4. Key Methods for Inter-Thread Communication**
*   Java provides specific methods for inter-thread communication: **`wait()`**, **`notify()`**, and **`notifyAll()`**.
*   **Important**: These methods can **only be called within a `synchronized` context** (either a `synchronized` method or a `synchronized` block).

    *   **`wait()` Method**:
        *   Tells the **current thread to release the lock** it holds.
        *   Causes the current thread to **wait until it is notified by another thread**.
        *   It is often used inside a `while` loop to re-check the condition after waking up, preventing spurious wake-ups.

    *   **`notify()` Method**:
        *   **Wakes up a single thread** that is waiting on the same object's lock.
        *   When `notify()` is called on a `SharedResource` object, it wakes up another thread trying to access that *same* `SharedResource` object. The waiting thread is then able to try and acquire the lock.

    *   **`notifyAll()` Method**:
        *   **Wakes up all threads** that are waiting on the same object's lock.
        *   This is useful when there might be **more than one thread waiting**. For example, if there is one Producer and multiple Consumers, `notifyAll()` can be used to wake up all waiting Consumers.

### Coding Example: Producer-Consumer with Thread Communication

This example demonstrates how `wait()` and `notify()` are used for inter-thread communication to ensure a producer and consumer work in sync, without busy waiting, thereby achieving thread safety.

**Scenario**: A `Producer` thread produces data (0-9), and a `Consumer` thread consumes it, ensuring that data is consumed only after it's produced, and produced only when the buffer (shared resource) is empty.

**1. `SharedResource` Class**
This class holds the data and a flag to indicate if data is present. It also contains the `produce` and `consume` methods, which are `synchronized` to ensure proper communication and thread safety.

```java
// SharedResource.java
public class SharedResource {
    private int data;
    private boolean hasData = false; // Flag to indicate if data is available

    // Method for the Producer to add data
    public synchronized void produce(int value) throws InterruptedException { // synchronized method
        // If there's already data, the Producer should wait
        while (hasData) { // Loop ensures it re-checks condition after waking up
            System.out.println("Producer: Buffer has data. Waiting...");
            wait(); // Releases lock and waits
        }

        // Produce data
        this.data = value;
        this.hasData = true;
        System.out.println("Produced: " + data);

        // Notify waiting Consumer thread(s)
        notify(); // Wakes up one waiting thread (Consumer)
    }

    // Method for the Consumer to retrieve data
    public synchronized int consume() throws InterruptedException { // synchronized method
        // If there's no data, the Consumer should wait
        while (!hasData) { // Loop ensures it re-checks condition after waking up
            System.out.println("Consumer: Buffer is empty. Waiting...");
            wait(); // Releases lock and waits
        }

        // Consume data
        int consumedData = this.data;
        this.hasData = false; // Buffer is now empty
        System.out.println("Consumed: " + consumedData);

        // Notify waiting Producer thread(s)
        notify(); // Wakes up one waiting thread (Producer)
        return consumedData;
    }
}
```
**Explanation for `SharedResource` Methods**:
*   Both `produce` and `consume` methods are declared `synchronized`. This means only one thread can execute either of these methods on the `SharedResource` object at any given time, providing a lock on the object. This is crucial for **thread safety**.
*   The `while(hasData)` condition in `produce` and `while(!hasData)` in `consume` ensure that threads wait if the buffer condition isn't met. This pattern prevents a common issue where a thread might proceed if it receives a `notify()` without the actual condition being met (known as a "spurious wakeup").
*   `wait()` is called when a thread needs to pause and release the lock on the `SharedResource` object, preventing busy waiting.
*   `notify()` is called after a thread has performed its action (produced or consumed data) to wake up one of the other waiting threads. This notification is for threads waiting on the *same object's lock*.
*   The `InterruptedException` must be handled with a `try-catch` block, and the video shows restoring the interrupt status of the current thread (`Thread.currentThread().interrupt()`).

**2. `Producer` Class**
This class implements `Runnable` and uses the `SharedResource` to produce data.

```java
// Producer.java
public class Producer implements Runnable {
    private SharedResource resource; // SharedResource field

    public Producer(SharedResource resource) { // Constructor
        this.resource = resource;
    }

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) { // Produce 10 items
            try {
                resource.produce(i); // Calls the produce method on the shared resource
                // Thread.sleep(100); // Simulate work (optional, for clearer output)
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt(); // Restore interrupt status
                System.out.println("Producer interrupted.");
                return; // Exit loop on interruption
            }
        }
    }
}
```
**Explanation for `Producer`**:
*   The `Producer` has a `SharedResource` instance passed in its constructor, ensuring it interacts with the common buffer.
*   Its `run` method iteratively calls the `produce` method on the `SharedResource` from `0` to `9`.

**3. `Consumer` Class**
This class also implements `Runnable` and uses the `SharedResource` to consume data.

```java
// Consumer.java
public class Consumer implements Runnable {
    private SharedResource resource; // SharedResource field

    public Consumer(SharedResource resource) { // Constructor
        this.resource = resource;
    }

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) { // Consume 10 items
            try {
                resource.consume(); // Calls the consume method on the shared resource
                // Thread.sleep(150); // Simulate work (optional, for clearer output)
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt(); // Restore interrupt status
                System.out.println("Consumer interrupted.");
                return; // Exit loop on interruption
            }
        }
    }
}
```
**Explanation for `Consumer`**:
*   Similar to the `Producer`, the `Consumer` receives the same `SharedResource` instance.
*   Its `run` method iteratively calls the `consume` method on the `SharedResource` ten times.

**4. `Main` Class to Run the Threads**
This class sets up the shared resource and starts the producer and consumer threads.

```java
// Main.java
public class Main {
    public static void main(String[] args) {
        SharedResource sharedResource = new SharedResource(); // Create one shared resource

        // Create producer and consumer tasks, passing the same shared resource
        Producer producerTask = new Producer(sharedResource);
        Consumer consumerTask = new Consumer(sharedResource);

        // Create threads for producer and consumer
        Thread producerThread = new Thread(producerTask);
        Thread consumerThread = new Thread(consumerTask);

        // Start the threads
        producerThread.start();
        consumerThread.start();

        // Optional: Wait for threads to complete
        try {
            producerThread.join();
            consumerThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println("Main thread interrupted while waiting for producer/consumer.");
        }
        System.out.println("All production and consumption complete.");
    }
}
```
**Explanation for `Main`**:
*   A **single instance of `SharedResource`** is created and passed to both the `Producer` and `Consumer` tasks. This is crucial as it represents the common buffer they interact with.
*   Separate `Thread` objects are created for the producer and consumer tasks.
*   `producerThread.start()` and `consumerThread.start()` initiate the execution of the `run()` methods in their respective `Runnable` tasks.
*   `join()` is used to make the main thread wait until the producer and consumer threads have finished their execution.
