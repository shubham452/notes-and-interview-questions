Here are notes with examples on essential Java Thread methods, drawing from the provided sources:

### Essential Java Thread Methods

The provided excerpts from "Master Java Threads: Essential Methods to Elevate Your Coding!" discuss several key methods used to manage and control Java threads.

1.  **`start()` Method**
    *   **Purpose:** This method is used to **begin the execution of a new thread**. When `start()` is invoked on a `Thread` object, the Java Virtual Machine (JVM) specifically calls the `run()` method of that thread in a separate execution context.
    *   **Important Note:** You should **never call the `run()` method directly** to start a new thread. Calling `run()` directly will execute the code in the same thread (the calling thread) and not in a new, separate thread.
    *   **Example:**
        ```java
        class MyThread extends Thread {
            @Override
            public void run() {
                System.out.println("My thread is running."); // This code executes in the new thread
            }
        }

        public class ThreadExample {
            public static void main(String[] args) {
                MyThread t1 = new MyThread();
                t1.start(); // Invokes run() in a new `run()` directly will execute the code in the same thread (the calling thread) and not in a new, separate thread.
    *   **Example:**
        ```java
        class MyThread extends Thread {
            @Override
            public void run() {
                System.out.println("My thread is running."); // This code executes in the new thread
            }
        }

        public class ThreadExample {
            public static void main(String[] args) {
                MyThread t1 = new MyThread();
                t1.start(); // Invokes run() in a new thread
            }
        }
        ```

2.  **`run()` Method**
    *   **Purpose:** The `run()` method contains the **code that will be executed by the new thread**. It is an overridden method from the `Thread` class (or the `Runnable` interface if implementing `Runnable`).
    *   **How it's used:** You write your business logic or the specific task you want the new thread to perform inside this method. The `start()` method implicitly calls this `run()` method.
    *   **Example:** (See example under `start()` method above).

3.  **`sleep(long millis)` Method**
    *   **Purpose:** The `sleep()` method is used to **pause the execution of the current thread for a specified duration** in milliseconds. During this time, the thread moves from a `RUNNABLE` state to a `TIMED_WAITING` state.
    *   **`InterruptedException`:** When using `Thread.sleep()`, it is a **checked exception** (`InterruptedException`) that must be handled. This exception is thrown if another thread interrupts the current thread while it is sleeping. If interrupted, the thread wakes up from its sleep prematurely.
    *   **Example:**
        ```java
        class MyThread extends Thread {
            @Override
            public void run() {
                for (int i = 1; i <= 5; i++) {
                    System.out.println(i);
                    try {
                        Thread.sleep(1000); // Pauses for 1 second
                    } catch (InterruptedException e) {
                        System.out.println("Thread was interrupted while sleeping!"); // Handled InterruptedException
                        // e.printStackTrace(); // Optional: print stack trace for debugging
                    }
                }
            }
        }

        public class SleepExample {
            public static void main(String[] args) {
                MyThread t1 = new MyThread();
                t1.start();
            }
        }
        ```
        If `t1.interrupt()` were called from `main` while `t1` was sleeping, the `InterruptedException` would be caught, and the message "Thread was interrupted while sleeping!" would print.

4.  **`join()` Method**
    *   **Purpose:** The `join()` method allows **one thread to wait for the completion of another thread**. When thread A calls `threadB.join()`, thread A will pause its execution and wait until `threadB` finishes its `run()` method.
    *   **Example:**
        ```java
        class MyThread extends Thread {
            @Override
            public void run() {
                try {
                    System.out.println(Thread.currentThread().getName() + " started working.");
                    Thread.sleep(3000); // Simulate work for 3 seconds
                    System.out.println(Thread.currentThread().getName() + " finished working.");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        public class JoinExample {
            public static void main(String[] args) throws InterruptedException { // Join can throw InterruptedException
                MyThread t1 = new MyThread();
                t1.setName("ChildThread"); // Naming the thread
                t1.start(); // Start the child thread

                System.out.println("Main thread wants to wait for ChildThread to finish.");
                t1.join(); // Main thread waits for t1 to complete
                System.out.println("Main thread resumed after ChildThread finished. Hello!"); // This will print after 3 seconds
            }
        }
        ```
        In this example, the "Hello!" message from the main thread will only print after `ChildThread` has completed its 3-second sleep and its `run()` method has finished.

5.  **`setPriority(int newPriority)` and `getPriority()` Methods**
    *   **Purpose:** Threads can have a priority level, which is an integer value ranging from `Thread.MIN_PRIORITY` (1) to `Thread.MAX_PRIORITY` (10), with `Thread.NORM_PRIORITY` (5) being the default.
    *   `setPriority()`: Allows you to **suggest to the CPU scheduler how important a thread is** relative to other threads.
    *   `getPriority()`: Retrieves the current priority of a thread.
    *   **Important Note:** Setting priority is merely a **hint to the scheduler**; it does not guarantee execution order or absolute precedence. The actual execution depends on the JVM, the operating system's scheduler, and the number of available CPU cores.
    *   **Example:**
        ```java
        class PriorityThread extends Thread {
            public PriorityThread(String name) {
                super(name); // Set thread name
            }

            @Override
            public void run() {
                for (int i = 0; i < 5; i++) {
                    System.out.println(Thread.currentThread().getName() + " Priority: " + Thread.currentThread().getPriority() + " Count: " + i);
                    try {
                        Thread.sleep(10); // Simulate some work
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }

        public class PriorityExample {
            public static void main(String[] args) {
                PriorityThread low = new PriorityThread("LowPriorityThread");
                PriorityThread normal = new PriorityThread("NormalPriorityThread");
                PriorityThread high = new PriorityThread("HighPriorityThread");

                low.setPriority(Thread.MIN_PRIORITY); // Sets priority to 1
                normal.setPriority(Thread.NORM_PRIORITY); // Sets priority to 5
                high.setPriority(Thread.MAX_PRIORITY); // Sets priority to 10

                low.start();
                normal.start();
                high.start();
            }
        }
        ```
        Even with different priorities, the output might show mixed execution, demonstrating that priority is a hint, not a strict rule.

6.  **Thread Naming**
    *   **Purpose:** You can **give a custom name to a thread** to make debugging and logging easier.
    *   **How to set a name:**
        *   Pass the name to the `Thread` constructor when creating an instance (e.g., `super(name)` in a subclass constructor).
        *   Use the `setName()` method (not explicitly shown in excerpts but implied).
    *   **Example:** (See examples under `join()` and `setPriority()` methods where `new MyThread("ChildThread")` and `super(name)` are used).

7.  **`interrupt()` Method**
    *   **Purpose:** The `interrupt()` method is used to **signal a thread that it should stop what it's doing**, particularly if it's in a waiting or sleeping state. It's a cooperative mechanism, meaning the interrupted thread must handle the interruption.
    *   **Behavior:** If a thread is `sleep()`ing or `wait()`ing when `interrupt()` is called on it, an `InterruptedException` is thrown, causing the thread to wake up. If the thread is not in such a state, the `interrupted` flag is simply set, which the thread can later check using `Thread.interrupted()` or `isInterrupted()`.
    *   **Example:**
        ```java
        class InterruptibleThread extends Thread {
            @Override
            public void run() {
                try {
                    System.out.println(getName() + " is going to sleep for 5 seconds.");
                    Thread.sleep(5000); // This thread will sleep
                    System.out.println(getName() + " woke up naturally."); // This line might not print if interrupted
                } catch (InterruptedException e) {
                    System.out.println(getName() + " was interrupted while sleeping! Exception: " + e.getMessage()); // Prints the exception message
                }
                System.out.println(getName() + " has finished its execution.");
            }
        }

        public class InterruptExample {
            public static void main(String[] args) throws InterruptedException {
                InterruptibleThread t1 = new InterruptibleThread();
                t1.setName("SleeperThread");
                t1.start();

                Thread.sleep(1000); // Main thread sleeps for 1 second
                System.out.println("Main thread is interrupting SleeperThread...");
                t1.interrupt(); // Interrupt SleeperThread
            }
        }
        ```
        In this example, "SleeperThread was interrupted while sleeping!" will print, and the thread will not complete its full 5-second sleep.

8.  **`yield()` Method**
    *   **Purpose:** The `yield()` method is a **hint to the scheduler** that the current thread is willing to temporarily pause its execution and allow other threads of the same or higher priority to run.
    *   **Important Note:** Like `setPriority()`, `yield()` is merely a **hint and not a guarantee**. The scheduler is free to ignore this hint. It's typically used in situations where a thread is doing an intensive computation within a loop and wants to be polite to other threads.
    *   **Example:**
        ```java
        class YieldThread extends Thread {
            public YieldThread(String name) {
                super(name);
            }

            @Override
            public void run() {
                for (int i = 0; i < 5; i++) {
                    System.out.println(getName() + " is running. Count: " + i);
                    Thread.yield(); // Hint to scheduler to let other threads run
                }
            }
        }

        public class YieldExample {
            public static void main(String[] args) {
                YieldThread t1 = new YieldThread("Thread-1");
                YieldThread t2 = new YieldThread("Thread-2");

                t1.start();
                t2.start();
                // Without yield(), one thread might complete all its iterations before the other gets a chance
                // With yield(), output will appear more interleaved, showing both threads getting CPU time
            }
        }
        ```
        The output when `yield()` is used will generally show a more interleaved execution between `Thread-1` and `Thread-2` compared to when `yield()` is not used.

9.  **`setDaemon(boolean on)` Method**
    *   **Purpose:** This method is used to mark a thread as either a **user thread** (non-daemon, default) or a **daemon thread**.
    *   **User Threads:** These are typical threads that perform your main business logic. The JVM will **not terminate** until all user threads have completed their execution.
    *   **Daemon Threads:** These are background threads that perform supporting tasks (e.g., Garbage Collector in Java). The JVM will **terminate** if only daemon threads remain running, regardless of whether they have finished their tasks. Daemon threads are considered "helper" threads that do not prevent the application from exiting.
    *   **Important Note:** `setDaemon()` must be called **before the thread is started** (`thread.start()`).
    *   **Example:**
        ```java
        class DaemonThreadExample extends Thread {
            @Override
            public void run() {
                int count = 0;
                while (true) { // Infinite loop
                    System.out.println(getName() + " running in background. Count: " + count++);
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        break; // Exit loop if interrupted
                    }
                }
            }
        }

        public class DaemonExample {
            public static void main(String[] args) throws InterruptedException {
                DaemonThreadExample daemonThread = new DaemonThreadExample();
                daemonThread.setName("Daemon-Task");
                daemonThread.setDaemon(true); // Mark as daemon thread
                daemonThread.start();

                // User thread
                DaemonThreadExample userThread = new DaemonThreadExample();
                userThread.setName("User-Task");
                // userThread.setDaemon(false); // Default, no need to explicitly set
                userThread.start();

                // Main thread (a user thread) finishes its work
                System.out.println("Main thread: Doing some primary work...");
                Thread.sleep(3000); // Main thread does work for 3 seconds
                System.out.println("Main thread: Done with primary work.");

                // After main thread finishes, the JVM checks if any user threads are still running.
                // If only daemonThread is left, JVM will exit.
                // If userThread is also running, JVM will wait for userThread to finish.
            }
        }
        ```
        In this example, if only `daemonThread` were running, the application would terminate after the `main` thread finishes. However, since `userThread` is also a user thread and runs indefinitely, the JVM will continue to wait for `userThread` to complete, even after the `main` thread finishes.
