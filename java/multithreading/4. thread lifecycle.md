Here are notes with examples on the Java Thread Lifecycle, building upon our previous discussion about thread creation:

### Java Thread Lifecycle States

Similar to how a human life progresses through different stages, a thread also goes through various **states** during its execution, from creation to termination. Understanding these states is crucial for managing concurrent programs effectively. Java defines a set of thread states, which you can check using methods like `threadObject.getState()`.

The primary states a thread can be in are:

1.  **NEW**
    *   **Definition:** A thread is in the `NEW` state when its object has been created using `new` operator, but the `start()` method has not yet been called. At this point, the thread is not yet executing any code.
    *   **Example:**
        ```java
        class MyThread extends Thread {
            @Override
            public void run() {
                System.out.println("My thread is running.");
            }
        }

        public class ThreadStatesExample {
            public static void main(String[] args) {
                MyThread t1 = new MyThread(); // Thread object created
                System.out.println("State after creation: " + t1.getState()); // Output: NEW
                // t1.start() has not been called yet.
            }
        }
        ```
        In this example, `t1.getState()` will return `NEW` because `start()` has not been invoked.

2.  **RUNNABLE**
    *   **Definition:** A thread enters the `RUNNABLE` state as soon as its `start()` method is called. In this state, the thread is **ready to run** and is waiting for the CPU scheduler to allocate processor time to it.
    *   **Important Note:** In Java, the `RUNNABLE` state *also* encompasses the conceptual "running" state. Java's `Thread.State` enum does **not** have a distinct `RUNNING` state. This means if a thread is currently executing its `run()` method, its state will still be reported as `RUNNABLE`.
    *   **Example:**
        ```java
        class MyThread extends Thread {
            @Override
            public void run() {
                // This code is executed when the thread is in the RUNNABLE (and executing) state
                for (int i = 0; i < 5; i++) {
                    System.out.println(Thread.currentThread().getName() + " running...");
                }
            }
        }

        public class ThreadStatesExample {
            public static void main(String[] args) throws InterruptedException { // Added for Thread.sleep()
                MyThread t1 = new MyThread();
                System.out.println("State before start: " + t1.getState()); // Output: NEW

                t1.start(); // Invokes the run() method in a new thread
                System.out.println("State immediately after start: " + t1.getState()); // Output: RUNNABLE

                // To give t1 a chance to run and illustrate the 'running' aspect
                Thread.sleep(100); // Main thread sleeps, allowing t1 to run
                System.out.println("Main thread state (while running): " + Thread.currentThread().getState()); // Output: RUNNABLE
            }
        }
        ```
        After `t1.start()`, `t1.getState()` will be `RUNNABLE`. Even while the `main` thread is actively executing `System.out.println`, its state (checked by `Thread.currentThread().getState()`) will also be `RUNNABLE`.

3.  **BLOCKED / WAITING / TIMED_WAITING**
    *   These states represent scenarios where a thread is temporarily inactive, paused, or waiting for some condition to be met.
    *   **BLOCKED:** A thread enters the `BLOCKED` state when it's waiting to acquire a monitor lock to enter a synchronized block or method, but the lock is currently held by another thread.
    *   **WAITING:** A thread enters the `WAITING` state when it calls methods like `Object.wait()` (without a timeout), `Thread.join()` (without a timeout), or `LockSupport.park()`. It remains in this state indefinitely until another thread explicitly awakens it (e.g., via `notify()` or `notifyAll()`) or the joined thread finishes.
        *   **Example (`Thread.join()`):**
            ```java
            class MyThread extends Thread {
                @Override
                public void run() {
                    try {
                        Thread.sleep(2000); // Simulate work, puts t1 into TIMED_WAITING for 2s
                        System.out.println(Thread.currentThread().getName() + " finished its work.");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }

            public class ThreadStatesExample {
                public static void main(String[] args) throws InterruptedException {
                    MyThread t1 = new MyThread();
                    t1.start();

                    // Main thread waits for t1 to complete
                    System.out.println("Main thread is about to join t1...");
                    t1.join(); // Main thread goes into WAITING state until t1 dies
                    System.out.println("Main thread resumed. t1 state after join: " + t1.getState()); // Output after t1 finishes: TERMINATED
                }
            }
            ```
            When `t1.join()` is called, the `main` thread enters a `WAITING` state until `t1` completes its execution.
    *   **TIMED_WAITING:** A thread enters the `TIMED_WAITING` state when it calls methods that specify a timeout, such as `Thread.sleep(long millis)`, `Object.wait(long millis)`, `Thread.join(long millis)`, `LockSupport.parkNanos(long nanos)`, or `LockSupport.parkUntil(long deadline)`. The thread will wait for the specified duration or until awakened by another thread.
        *   **Example (`Thread.sleep()`):**
            ```java
            class MyThread extends Thread {
                @Override
                public void run() {
                    try {
                        System.out.println(Thread.currentThread().getName() + " is going to sleep...");
                        Thread.sleep(2000); // Puts this thread (t1) into TIMED_WAITING state for 2 seconds
                        System.out.println(Thread.currentThread().getName() + " woke up.");
                    } catch (InterruptedException e) {
                        System.out.println(Thread.currentThread().getName() + " was interrupted.");
                    }
                }
            }

            public class ThreadStatesExample {
                public static void main(String[] args) throws InterruptedException {
                    MyThread t1 = new MyThread();
                    t1.start();

                    // Give t1 a moment to start and then check its state while sleeping
                    Thread.sleep(100); // Allow t1 to enter sleep
                    System.out.println("State of t1 while sleeping: " + t1.getState()); // Output: TIMED_WAITING
                }
            }
            ```
            When `Thread.sleep(2000)` is called inside `MyThread`'s `run()` method, `t1` enters the `TIMED_WAITING` state for 2 seconds.

4.  **TERMINATED**
    *   **Definition:** A thread enters the `TERMINATED` state when it has finished executing its `run()` method. Once a thread is terminated, it cannot be restarted.
    *   **Example:**
        ```java
        class MyThread extends Thread {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + " is completing its task.");
                // The run method finishes here
            }
        }

        public class ThreadStatesExample {
            public static void main(String[] args) throws InterruptedException {
                MyThread t1 = new MyThread();
                t1.start();

                // Ensure t1 has time to finish
                t1.join(); // Main thread waits for t1 to terminate

                System.out.println("State of t1 after it has finished: " + t1.getState()); // Output: TERMINATED
            }
        }
        ```
        After `t1.run()` completes and `t1.join()` returns, `t1.getState()` will be `TERMINATED`.

### Handling `InterruptedException` with `Thread.sleep()`

When using `Thread.sleep()`, Java requires you to handle a `Checked Exception` called `InterruptedException`. This exception is thrown if another thread interrupts the current thread while it is sleeping. You typically handle it using a `try-catch` block or by declaring it in the method signature with `throws InterruptedException`.

**Example:**
```java
public class SleepExample {
    public static void main(String[] args) {
        try {
            System.out.println("Main thread is going to sleep...");
            Thread.sleep(1000); // Sleep for 1 second
            System.out.println("Main thread woke up.");
        } catch (InterruptedException e) {
            System.out.println("Main thread was interrupted!");
            // e.printStackTrace(); // Optional: print stack trace for debugging
        }
    }
}
```
