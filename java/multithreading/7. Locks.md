Java concurrency mechanisms like locks are essential for managing **shared resources** in **multi-threaded environments**. Without proper synchronization, multiple threads attempting to access and modify the same resource simultaneously can lead to chaotic, "jumbled," and "messed up" results. The video uses an analogy of three children trying to write in one notebook to illustrate this problem; without a supervisor (or synchronization), their writing would be illegible.

To prevent such issues, **locking** is employed, which ensures that only **one thread can access a shared resource at a time**. When a thread acquires a lock, it "locks" the resource, preventing other threads from accessing it until the lock is released.

There are two main types of locks in Java: **Intrinsic Locks** and **Explicit Locks**.

### Intrinsic Locks (using `synchronized` keyword)

*   **Built-in:** Every object in Java has an intrinsic (built-in) lock.
*   **Automatic:** When you use the `synchronized` keyword, you are automatically utilizing these intrinsic locks. For example, if a `withdraw` method is `synchronized`, only one thread can execute that method on a given object at any time.
*   **How it works:** When a thread accesses a `synchronized` block or method, it acquires the object's intrinsic lock. Other threads attempting to access the same `synchronized` block/method on the same object will have to wait until the first thread finishes and releases the lock.
*   **Example (without `synchronized`):**
    Imagine a `BankAccount` class with a `balance`:
    ```java
    class BankAccount {
        private int balance = 100; // Shared resource

        public void withdraw(int amount) {
            // ... (code for withdrawal)
        }
    }
    ```
    If two threads (`t1` and `t2`) simultaneously try to withdraw 50 from the same `BankAccount` without synchronization, the `balance` could become incorrect due to race conditions.
*   **Problem with `synchronized`:** While `synchronized` is simple to use, it offers **limited control**. A significant issue is that threads waiting for a `synchronized` lock will **wait indefinitely** until the lock is released. If the thread holding the lock encounters a long-running process (e.g., a simulated 10-second wait using `Thread.sleep`) or gets stuck, other waiting threads will remain blocked indefinitely, potentially leading to performance issues or even a frozen application.

### Explicit Locks (using `java.util.concurrent.locks.Lock` interface)

*   **Manual Control:** Explicit locks, like those implemented by the `ReentrantLock` class, provide **more advanced and manual control** over when and how locks are acquired and released. You explicitly tell the program when to `lock()` and `unlock()`.
*   **`ReentrantLock`:** This is a class that implements the `Lock` interface, offering flexible locking mechanisms. It's called "ReentrantLock" because it supports **reentrancy**, meaning a thread that has already acquired the lock can acquire it again without blocking itself.

#### Key Methods of `ReentrantLock`:

1.  **`lock()`:**
    *   Acquires the lock. If the lock is not available, the current thread **waits indefinitely** until the lock is acquired. This behavior is similar to `synchronized`.
    *   **Usage:** `lockObject.lock();`

2.  **`tryLock()`:**
    *   Attempts to acquire the lock **only if it is free at the time of invocation**.
    *   It returns `true` if the lock was acquired and `false` immediately if it was not.
    *   It **does not wait**, which means threads are not blocked indefinitely.
    *   **Usage:**
        ```java
        if (lock.tryLock()) {
            // Lock acquired, proceed with critical section
        } else {
            // Lock not available, do something else (e.g., print a message, try again later)
            System.out.println(Thread.currentThread().getName() + " could not acquire the lock. Will try again later.");
        }
        ```
        In the `BankAccount` example, if `t2` attempts to withdraw and `t1` holds the lock, `t2.tryLock()` would return `false`, allowing `t2` to decide not to wait and print "could not acquire the lock".

3.  **`tryLock(long timeout, TimeUnit unit)`:**
    *   Attempts to acquire the lock within a **given waiting time**.
    *   The thread will **wait for the specified duration** for the lock to become free.
    *   Returns `true` if the lock is acquired within the timeout, `false` otherwise.
    *   Can throw an `InterruptedException` if the thread is interrupted while waiting.
    *   **Usage:**
        ```java
        try {
            if (lock.tryLock(1000, TimeUnit.MILLISECONDS)) { // Wait for up to 1 second
                // Lock acquired, proceed
            } else {
                // Lock not available within 1 second, do something else
            }
        } catch (InterruptedException e) {
            // Handle interruption
            Thread.currentThread().interrupt(); // Re-interrupt the thread
        }
        ```

4.  **`unlock()`:**
    *   **Releases the lock** that was acquired by the current thread.
    *   It is crucial to call `unlock()` in a `finally` block to ensure that the lock is always released, even if exceptions occur within the critical section. This prevents other threads from being indefinitely blocked.
    *   **Usage:** `lockObject.unlock();`

5.  **`lockInterruptibly()`:**
    *   Acquires the lock unless the current thread is **interrupted**.
    *   If the thread is interrupted while waiting for the lock, an `InterruptedException` is thrown. This allows for a way to break out of a waiting state if needed, unlike the plain `lock()` method.
    *   **Usage:**
        ```java
        try {
            lock.lockInterruptibly();
            // Critical section
        } catch (InterruptedException e) {
            // Handle interruption
            Thread.currentThread().interrupt();
        } finally {
            if (lock.isHeldByCurrentThread()) { // Check if lock is held before unlocking
                lock.unlock();
            }
        }
        ```

#### **Code Example: Bank Account with `ReentrantLock`**

Here's how the `BankAccount` and `withdraw` method would be implemented using `ReentrantLock` to address the indefinite waiting issue:

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class BankAccount {
    private int balance = 100; // Shared resource
    private final Lock lock = new ReentrantLock(); // Explicit Lock object

    public void withdraw(int amount) {
        System.out.println(Thread.currentThread().getName() + " Attempting to withdraw " + amount);

        // Try to acquire the lock, waiting for a short time if necessary
        try {
            // tryLock(1000, TimeUnit.MILLISECONDS) means wait up to 1 second
            if (lock.tryLock(1000, TimeUnit.MILLISECONDS)) { //
                try {
                    // Critical Section: Code that accesses and modifies the shared resource
                    if (balance >= amount) {
                        System.out.println(Thread.currentThread().getName() + " Proceeding with withdrawal.");
                        // Simulate some processing time
                        Thread.sleep(3000); // Simulate 3 seconds processing
                        balance -= amount;
                        System.out.println(Thread.currentThread().getName() + " Completed withdrawal. Remaining Balance: " + balance);
                    } else {
                        System.out.println(Thread.currentThread().getName() + " Insufficient Balance.");
                    }
                } catch (InterruptedException e) {
                    System.out.println(Thread.currentThread().getName() + " Interrupted during withdrawal.");
                    // Good practice: Re-interrupt the current thread to preserve its interrupted status
                    Thread.currentThread().interrupt();
                } finally {
                    // Crucial: Release the lock in a finally block to ensure it's always released
                    lock.unlock(); //
                }
            } else {
                // Lock not acquired within the specified time
                System.out.println(Thread.currentThread().getName() + " Could not acquire the lock. Will try again later.");
            }
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + " Interrupted while trying to acquire lock.");
            Thread.currentThread().interrupt(); // Re-interrupt
        }
    }
}

// Main method to test
public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(); // One shared bank account

        // Create two threads to withdraw from the same account
        Runnable task = () -> account.withdraw(50); // Each thread tries to withdraw 50

        Thread t1 = new Thread(task, "Thread-1"); //
        Thread t2 = new Thread(task, "Thread-2"); //

        t1.start(); // Start threads
        t2.start(); // Start threads
    }
}
```

In this example, when `Thread-1` starts processing a withdrawal (and holds the lock for 3 seconds), `Thread-2` will attempt to acquire the lock using `tryLock(1000, TimeUnit.MILLISECONDS)`. Since `Thread-1` will hold the lock for longer than 1 second, `Thread-2` will fail to acquire it within its waiting time and print "Could not acquire the lock. Will try again later," rather than waiting indefinitely.

#### Handling `InterruptedException`

When using methods like `tryLock(long timeout, TimeUnit unit)` or `lockInterruptibly()`, an `InterruptedException` can be thrown. It's crucial not to simply catch and ignore this exception or just log it. The proper way to handle it is to **re-interrupt the current thread** by calling `Thread.currentThread().interrupt()` within the `catch` block. This ensures that the thread's interrupted status is restored, allowing higher-level code or monitoring systems to be aware that the thread was interrupted and potentially perform cleanup operations or log the event correctly. Failing to do so can lead to information loss about the thread's state and delayed shutdown.

#### Reentrancy Explained (`ReentrantLock` and `synchronized`)

**Reentrancy** means that a thread that already holds a lock can **re-acquire** that same lock without blocking itself. Both `ReentrantLock` and the `synchronized` keyword exhibit reentrancy.

Consider an example:

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ReentrantExample {
    private final Lock lock = new ReentrantLock(); // ReentrantLock object

    public void outerMethod() {
        lock.lock(); // First lock acquisition by the thread
        try {
            System.out.println("Outer Method entered."); //
            innerMethod(); // Calls another method that also tries to acquire the lock
        } finally {
            lock.unlock(); // Releases the lock
        }
    }

    public void innerMethod() {
        lock.lock(); // Second lock acquisition by the SAME thread
        try {
            System.out.println("Inner Method entered."); //
        } finally {
            lock.unlock(); // Releases the lock
        }
    }

    public static void main(String[] args) {
        ReentrantExample example = new ReentrantExample();
        example.outerMethod(); // Main thread calls outerMethod
    }
}
```

If the lock were not reentrant, when `outerMethod` calls `innerMethod`, the `innerMethod` would try to acquire the same lock that `outerMethod` already holds. This would lead to a **deadlock**, where the thread is waiting for itself to release the lock.

However, because `ReentrantLock` (and `synchronized`) is reentrant, this doesn't happen.
*   When `lock.lock()` is called in `outerMethod`, the lock is acquired, and an internal **count is incremented** (e.g., to 1).
*   When `innerMethod` is called by the **same thread**, and `lock.lock()` is called again, the lock is successfully acquired, and the **count is incremented again** (e.g., to 2). The thread does not block.
*   When `lock.unlock()` is called in `innerMethod`, the **count is decremented** (e.g., to 1), but the lock is **not fully released** because the count is not zero.
*   Only when `lock.unlock()` is called in `outerMethod` (bringing the count to 0) is the lock truly released, allowing other threads to acquire it.

This mechanism ensures that a thread can acquire the same lock multiple times as long as it also calls `unlock()` an equal number of times. This is like having the main key to a house, allowing you to enter any room without needing to "unlock" the main door again for yourself.
