Here are notes and a coding example based on the video transcript, explaining Java Deadlock and its resolution:

### Notes on Java Deadlock

*   **What is Deadlock?**
    *   In multi-threading, deadlock is a situation where multiple threads become **permanently blocked**.
    *   These threads are stuck waiting for each other to release resources that they need to proceed.
    *   **No work gets done**, and the waiting continues indefinitely.
    *   **Analogy**: Thread A has a pen and waits for paper from Thread B. Thread B has paper and waits for a pen from Thread A. Neither can proceed.

*   **Formal Conditions for Deadlock**:
    1.  **Mutual Exclusion**: Resources (critical sections) must be under a lock, meaning only one thread can use a resource at a time.
    2.  **Hold and Wait**: A thread holding at least one resource is simultaneously waiting to acquire another resource that is currently held by a different thread.
    3.  **No Preemption**: Resources cannot be forcibly taken away from a thread; they must be voluntarily released by the thread holding them.
    4.  **Circular Wait**: A set of threads are waiting for resources in a circular fashion (e.g., Thread 1 waits for a resource held by Thread 2, Thread 2 waits for a resource held by Thread 3, and so on, with Thread N waiting for a resource held by Thread 1).

*   **The Deadlocked Scenario: Pen & Paper Example**
    *   **Classes Involved**:
        *   `Pen` class: Contains a `synchronized` method `writeWithPenAndPaper(Paper paper)` which, internally, calls `paper.finishWriting()`. It also has a `synchronized` `finishWriting()` method.
        *   `Paper` class: Contains a `synchronized` method `writeWithPaperAndPen(Pen pen)` which, internally, calls `pen.finishWriting()`. It also has a `synchronized` `finishWriting()` method.
    *   **Threads Involved**:
        *   `TaskOne` (Thread 1): Its `run` method calls `pen.writeWithPenAndPaper(paper)`.
        *   `TaskTwo` (Thread 2): Its `run` method calls `paper.writeWithPaperAndPen(pen)`.
    *   **How Deadlock Occurs**:
        1.  When a method is declared `synchronized`, it acquires the **intrinsic lock of the object** to which the method belongs.
        2.  **Thread 1 (via `TaskOne`)**:
            *   Starts by calling `pen.writeWithPenAndPaper(paper)`. This **acquires the `pen`'s lock**.
            *   Inside this method, it attempts to call `paper.finishWriting()`. Since `paper.finishWriting()` is also `synchronized` on the `paper` object, Thread 1 now **needs to acquire `paper`'s lock**.
        3.  **Thread 2 (via `TaskTwo`)**:
            *   Starts by calling `paper.writeWithPaperAndPen(pen)`. This **acquires the `paper`'s lock**.
            *   Inside this method, it attempts to call `pen.finishWriting()`. Since `pen.finishWriting()` is also `synchronized` on the `pen` object, Thread 2 now **needs to acquire `pen`'s lock**.
        4.  **The Stalemate**: Thread 1 holds `pen`'s lock and waits for `paper`'s lock (which is held by Thread 2). Thread 2 holds `paper`'s lock and waits for `pen`'s lock (which is held by Thread 1). Neither can proceed, leading to a permanent block and output indicating they are "trying to use" the other resource indefinitely.

*   **Resolving Deadlock: Consistent Lock Ordering**
    *   The primary strategy to resolve deadlock is to **ensure that all threads acquire locks in a consistent, predefined order**.
    *   This means if threads need multiple resources, they should always attempt to acquire the locks for those resources in the **same sequence**.
    *   **Application to Pen & Paper Example**:
        *   The original problem was that Thread 1 acquired `pen` then `paper`, while Thread 2 acquired `paper` then `pen`, creating a circular dependency.
        *   To resolve this, the video suggests **changing the lock acquisition order for `TaskTwo`** to match `TaskOne`'s preferred order.
        *   Specifically, `TaskTwo` should also **first try to acquire `pen`'s lock, and then `paper`'s lock**.
        *   This is achieved by making `TaskTwo` call `pen.writeWithPenAndPaper(paper)` instead of `paper.writeWithPaperAndPen(pen)`.
        *   **Outcome**: If Thread 1 acquires `pen`'s lock, Thread 2 will be blocked trying to acquire `pen`'s lock (its first required lock). Thread 1 can then acquire `paper`'s lock, complete its task, and release both locks. Once `pen`'s lock is released, Thread 2 can proceed, acquire `pen`'s lock, then `paper`'s lock, and complete its task. This breaks the circular wait condition, allowing both threads to execute successfully.

---

### Coding Example

Here's a Java coding example demonstrating the deadlock scenario and its resolution, as explained in the video transcript:

```java
import java.util.concurrent.TimeUnit;

// 1. Resource Classes: Pen and Paper
// Both classes have synchronized methods, which implicitly acquire the object's lock.
// The nested calls to synchronized methods create the potential for deadlock.

class Pen {
    private String owner;

    public Pen(String owner) {
        this.owner = owner;
    }

    public String getOwner() {
        return owner;
    }

    // This method is synchronized on the Pen object (this)
    public synchronized void writeWithPenAndPaper(Paper paper) {
        System.out.println(Thread.currentThread().getName() + " HAS " + owner + "'s Pen and is trying to use " + paper.getOwner() + "'s Paper.");
        try {
            // Simulate some work or delay to increase likelihood of deadlock
            TimeUnit.MILLISECONDS.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        // Attempt to acquire Paper's lock by calling its synchronized method
        paper.finishWriting();
    }

    // This method is synchronized on the Pen object (this)
    public synchronized void finishWriting() {
        System.out.println(Thread.currentThread().getName() + " finished writing with " + owner + "'s Pen.");
    }
}

class Paper {
    private String owner;

    public Paper(String owner) {
        this.owner = owner;
    }

    public String getOwner() {
        return owner;
    }

    // This method is synchronized on the Paper object (this)
    public synchronized void writeWithPaperAndPen(Pen pen) {
        System.out.println(Thread.currentThread().getName() + " HAS " + owner + "'s Paper and is trying to use " + pen.getOwner() + "'s Pen.");
        try {
            // Simulate some work or delay to increase likelihood of deadlock
            TimeUnit.MILLISECONDS.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        // Attempt to acquire Pen's lock by calling its synchronized method
        pen.finishWriting();
    }

    // This method is synchronized on the Paper object (this)
    public synchronized void finishWriting() {
        System.out.println(Thread.currentThread().getName() + " finished writing with " + owner + "'s Paper.");
    }
}

// 2. Runnable Tasks
// These tasks define the actions threads will perform, leading to or resolving deadlock.

// Task for Thread 1: Acquires Pen lock, then tries to acquire Paper lock
class TaskOne implements Runnable {
    private Pen pen;
    private Paper paper;

    public TaskOne(Pen pen, Paper paper) {
        this.pen = pen;
        this.paper = paper;
    }

    @Override
    public void run() {
        // Thread 1 first tries to lock 'pen' then 'paper'
        pen.writeWithPenAndPaper(paper);
        System.out.println(Thread.currentThread().getName() + " completed its task.");
    }
}

// Task for Thread 2: Deadlocked version - Acquires Paper lock, then tries to acquire Pen lock
class DeadlockedTaskTwo implements Runnable {
    private Pen pen;
    private Paper paper;

    public DeadlockedTaskTwo(Pen pen, Paper paper) {
        this.pen = pen;
        this.paper = paper;
    }

    @Override
    public void run() {
        // Thread 2 first tries to lock 'paper' then 'pen'
        paper.writeWithPaperAndPen(pen);
        System.out.println(Thread.currentThread().getName() + " completed its task."); // This line might not be reached in deadlock
    }
}

// Task for Thread 2: Resolved version - Acquires Pen lock, then tries to acquire Paper lock (consistent order)
class ResolvedTaskTwo implements Runnable {
    private Pen pen;
    private Paper paper;

    public ResolvedTaskTwo(Pen pen, Paper paper) {
        this.pen = pen;
        this.paper = paper;
    }

    @Override
    public void run() {
        // Thread 2 now also tries to lock 'pen' then 'paper', same as TaskOne
        pen.writeWithPenAndPaper(paper);
        System.out.println(Thread.currentThread().getName() + " completed its task.");
    }
}

// 3. Main Class to Demonstrate Deadlock
public class DeadlockExample {

    public static void main(String[] args) {
        System.out.println("--- Demonstrating Deadlock ---");

        // Create shared resources
        Pen myPen = new Pen("My");
        Paper myPaper = new Paper("My");

        // Create tasks that lead to deadlock
        TaskOne task1 = new TaskOne(myPen, myPaper);
        DeadlockedTaskTwo task2Deadlocked = new DeadlockedTaskTwo(myPen, myPaper);

        // Create threads
        Thread thread1 = new Thread(task1, "Thread-1");
        Thread thread2Deadlocked = new Thread(task2Deadlocked, "Thread-2-Deadlocked");

        // Start threads
        thread1.start();
        thread2Deadlocked.start();

        System.out.println("Threads started. Waiting for completion (or deadlock)...");

        // Use a timeout to observe deadlock, as join() would wait forever
        try {
            thread1.join(2000); // Wait up to 2 seconds
            thread2Deadlocked.join(2000); // Wait up to 2 seconds
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.err.println("Main thread interrupted.");
        }

        if (thread1.isAlive() || thread2Deadlocked.isAlive()) {
            System.out.println("\n!!! DEADLOCK DETECTED !!! Threads are still alive and blocked.");
            // You might want to stop the application or kill the threads here in a real scenario
            System.exit(0); // Terminate the program because of deadlock
        } else {
            System.out.println("\nBoth threads completed successfully (unlikely if deadlock occurred quickly).");
        }
    }
}

// 4. Main Class to Demonstrate Resolution
class ResolvedDeadlockExample {

    public static void main(String[] args) {
        System.out.println("\n--- Demonstrating Deadlock Resolution ---");

        // Create shared resources
        Pen myPen = new Pen("My");
        Paper myPaper = new Paper("My");

        // Create tasks that resolve deadlock by consistent lock ordering
        TaskOne task1 = new TaskOne(myPen, myPaper); // Thread 1: Pen -> Paper
        ResolvedTaskTwo task2Resolved = new ResolvedTaskTwo(myPen, myPaper); // Thread 2: Pen -> Paper (changed!)

        // Create threads
        Thread thread1 = new Thread(task1, "Thread-1-Resolved");
        Thread thread2Resolved = new Thread(task2Resolved, "Thread-2-Resolved");

        // Start threads
        thread1.start();
        thread2Resolved.start();

        System.out.println("Resolved threads started. Waiting for completion...");

        // Wait for both threads to complete
        try {
            thread1.join();
            thread2Resolved.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.err.println("Main thread interrupted.");
        }

        System.out.println("\nBoth resolved threads completed successfully.");
    }
}
```

**To run this code:**

1.  Save the code as `DeadlockExample.java` and `ResolvedDeadlockExample.java` in the same directory.
2.  Compile using `javac DeadlockExample.java ResolvedDeadlockExample.java`.
3.  Run the `DeadlockExample` first: `java DeadlockExample`. You should observe the threads getting stuck, printing messages about "HAS Pen and is trying to use Paper" and "HAS Paper and is trying to use Pen", and eventually, the program will terminate with a "DEADLOCK DETECTED" message because of `System.exit(0)`.
4.  Run the `ResolvedDeadlockExample`: `java ResolvedDeadlockExample`. You should see both threads completing their tasks successfully, as the consistent lock acquisition order prevents deadlock.
