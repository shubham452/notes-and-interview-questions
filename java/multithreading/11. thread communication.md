Here are notes and a coding example on **Thread Communication** as presented in the video, drawing on the provided source:

### Notes on Thread Communication

**1. What is Thread Communication?**
*   In a multi-threading environment, **threads need to communicate with each other**. This is known as **Thread Communication**.
*   Without proper communication, threads can enter a **"busy waiting state"**.
*   **Busy waiting** means threads continuously check conditions (e.g., "is my turn yet?"), which **wastes CPU resources**.
*   This waste can lead to **potential deadlocks**.
*   The goal of thread communication is to **save CPU resources** by allowing threads to inform each other about state changes.

**2. Problem Without Thread Communication (Producer-Consumer Analogy)**
*   Consider a **Producer** thread that generates data and a **Consumer** thread that uses it.
*   Without proper inter-thread communication, the Consumer would constantly check if new data is available. This continuous checking wastes CPU.
*   Ideally, the Producer should simply **notify** the Consumer when new data is ready, and vice versa.

**3. Key Methods for Inter-Thread Communication**
*   The Java language provides specific methods for inter-thread communication: `wait()`, `notify()`, and `notifyAll()`.
*   **Important**: These methods can **only be called within a `synchronized` context** (either a `synchronized` method or a `synchronized` block).

    *   **`wait()` Method**:
        *   Tells the **current thread to release the lock** it holds.
        *   Causes the current thread to **wait** until it is notified by another thread.

    *   **`notify()` Method**:
        *   **Wakes up a single thread** that is waiting on the same object's lock.
        *   When `notify()` is called on a `SharedResource` object, it wakes up another thread trying to access that same `SharedResource` object.

    *   **`notifyAll()` Method**:
        *   **Wakes up all threads** that are waiting on the same object's lock.
        *   This is useful when there might be **more than one thread waiting**. For example, if there is one Producer and multiple Consumers, `notifyAll()` can be used to wake up all waiting Consumers.

### Coding Example: Producer-Consumer with Thread Communication

This example demonstrates how `wait()` and `notify()` are used for inter-thread communication to ensure a producer and consumer work in sync, without busy waiting.

**Scenario**: A `Producer` thread produces data (0-9), and a `Consumer` thread consumes it, ensuring that data is consumed only after it's produced, and produced only when the buffer is empty.

**1. `SharedResource` Class**
This class holds the data and a flag to indicate if data is present. It also contains the `produce` and `consume` methods, which are `synchronized` to ensure proper communication.

```java
// SharedResource.java
public class SharedResource {
    private int data;
    private boolean hasData = false; // Flag to indicate if data is available

    // Method for the Producer to add data
    public synchronized void produce(int value) throws InterruptedException {
        // If there's already data, the Producer should wait
        while (hasData) { // Loop ensures it re-checks condition after waking up
            System.out.println("Producer: Buffer has data. Waiting...");
            wait(); // Releases lock and waits
        }

        // Produce data
        this.data = value;
        this.hasData = true;
        System.out.println("Produced: " + data);

        // Notify waiting Consumer thread(s)
        notify(); // Wakes up one waiting thread (Consumer)
    }

    // Method for the Consumer to retrieve data
    public synchronized int consume() throws InterruptedException {
        // If there's no data, the Consumer should wait
        while (!hasData) { // Loop ensures it re-checks condition after waking up
            System.out.println("Consumer: Buffer is empty. Waiting...");
            wait(); // Releases lock and waits
        }

        // Consume data
        int consumedData = this.data;
        this.hasData = false;
        System.out.println("Consumed: " + consumedData);

        // Notify waiting Producer thread(s)
        notify(); // Wakes up one waiting thread (Producer)
        return consumedData;
    }
}
```
**Explanation for `SharedResource` Methods**:
*   Both `produce` and `consume` methods are `synchronized` to ensure only one thread can access them at a time, protecting `data` and `hasData`.
*   The `while(hasData)` condition in `produce` and `while(!hasData)` in `consume` ensures that threads wait if the condition isn't met.
*   `wait()` is called when a thread needs to pause and release the lock, preventing busy waiting.
*   `notify()` is called after a thread has performed its action (produced or consumed data) to wake up the other waiting thread.
*   The `InterruptedException` must be handled with a `try-catch` block. The source shows re-interrupting the current thread to restore its state.

**2. `Producer` Class**
This class implements `Runnable` and uses the `SharedResource` to produce data.

```java
// Producer.java
public class Producer implements Runnable {
    private SharedResource resource;

    public Producer(SharedResource resource) {
        this.resource = resource;
    }

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) { // Produce 10 items
            try {
                resource.produce(i);
                Thread.sleep(100); // Simulate work
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt(); // Restore interrupt status
                System.out.println("Producer interrupted.");
                return; // Exit loop on interruption
            }
        }
    }
}
```
**Explanation for `Producer`**:
*   The `Producer` has a `SharedResource` instance passed in its constructor.
*   Its `run` method iteratively calls the `produce` method on the `SharedResource`.
*   A `Thread.sleep` is added to simulate processing time, though it's not explicitly in the transcript for this class, it's a common practice.

**3. `Consumer` Class**
This class also implements `Runnable` and uses the `SharedResource` to consume data.

```java
// Consumer.java
public class Consumer implements Runnable {
    private SharedResource resource;

    public Consumer(SharedResource resource) {
        this.resource = resource;
    }

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) { // Consume 10 items
            try {
                resource.consume();
                Thread.sleep(150); // Simulate work
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt(); // Restore interrupt status
                System.out.println("Consumer interrupted.");
                return; // Exit loop on interruption
            }
        }
    }
}
```
**Explanation for `Consumer`**:
*   Similar to the `Producer`, the `Consumer` receives the `SharedResource`.
*   Its `run` method calls the `consume` method on the `SharedResource`.
*   `Thread.sleep` is used here for simulation.

**4. `Main` Class**
This class sets up the shared resource and creates and starts the producer and consumer threads.

```java
// Main.java
public class Main {
    public static void main(String[] args) {
        SharedResource sharedResource = new SharedResource(); // One shared object

        // Create Producer and Consumer threads
        Thread producerThread = new Thread(new Producer(sharedResource));
        Thread consumerThread = new Thread(new Consumer(sharedResource));

        // Start both threads
        producerThread.start();
        consumerThread.start();

        // Optional: Wait for threads to finish (not explicitly in source, but good practice)
        try {
            producerThread.join();
            consumerThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        System.out.println("Program finished.");
    }
}
```
**Explanation for `Main`**:
*   A single instance of `SharedResource` is created, ensuring both threads operate on the same shared data.
*   A `Producer` and `Consumer` object are created, each wrapped in a `Thread`.
*   Both threads are started, allowing them to run concurrently and communicate through the `SharedResource`.

**Output Demonstration**:
When this code runs, the output will show an interleaved sequence of "Produced: X" and "Consumed: X", ensuring that data is consumed in the correct order and only after it has been produced. For example:
```
Produced: 0
Consumed: 0
Produced: 1
Consumed: 1
Produced: 2
Consumed: 2
...
```
This synchronized output demonstrates that **threads are communicating effectively**, preventing busy waiting and deadlocks. The `hasData` flag and `wait`/`notify` methods ensure this synchronization. The lock mechanism is applied to the `SharedResource` object itself.
